!function() {
    function require(path, parent) {
        path = resolve(parent, path);
        var module = modules[path];
        if (!module) throw new Error('failed to require "' + path + '" from ' + parent);
        if (typeof module === "string") {
            new Function("module", "exports", "require", "eval(" + JSON.stringify(module + "\n//@ sourceURL=" + encodeURI(path)) + ")").call((modules[path] = module = {
                exports: {}
            }).exports, module, module.exports, function(relp) {
                return require("." === relp[0] ? join(path, relp) : relp, path);
            });
        }
        return module.exports;
    }
    function resolve(base, path) {
        if (path[0] === "/" || path.match(/^[a-zA-Z]+:/)) {
            return modules[path] && path || modules[path + ".js"] && path + ".js" || modules[path + ".json"] && path + ".json" || modules[path + "index.js"] && path + "index.js" || modules[path + "/index.js"] && path + "/index.js";
        } else {
            var res;
            do {
                for (var i = 0, len = checks.length; i < len; i++) {
                    if (res = checks[i](modules, base, path)) return res;
                }
            } while ((base = parentDir(base)) !== "/");
        }
    }
    function parentDir(path) {
        return path.split("/").slice(0, -1).join("/") || "/";
    }
    var checks = [ function node_modules(hash, base, name) {
        if (hash["/node_core/" + name + ".js"]) return "/node_core/" + name + ".js";
        return [ name, name + ".js", name + ".json", name + "/index.js", name + "/index.json", name + "/package.json" ].map(function(p) {
            return base + "/node_modules/" + p;
        }).filter(function(p) {
            return !!hash[p];
        })[0];
    }, function components(hash, base, name) {
        return [ name, name + "/component.json" ].map(function(p) {
            return base + "/components/" + p;
        }).filter(function(p) {
            return !!hash[p];
        })[0];
    } ];
    function join(a, b) {
        var path = a.split("/").slice(0, -1), segs = b.split("/"), i = -1;
        while (++i < segs.length) {
            if (".." === segs[i]) path.pop(); else if ("." !== segs[i]) path.push(segs[i]);
        }
        return path.join("/");
    }
    var modules = {
        "/home/jkroso/Dev/Libraries/Mouse/demo/demo.js": "var Mouse = require('../src'),\r\n    Dom411 = require('Dom411'),\r\n    happen = require('./happen'),\r\n    Promise = require('laissez-faire'),\r\n    all = require('promises').all\r\n\r\nvar total, timer, top, left\r\n\r\nvar now = performance.now && function () {return performance.now()}\r\n    || performance.webkitNow && function () {return performance.webkitNow()}\r\n    || Date.now\r\n\r\n// This causes just a single dom event listener\r\nDom411('#Direct > .item')\r\n    .on('grab.left', start)\r\n    .on('drag.left', move)\r\n    .on('drop.left', stop)\r\n\r\n// This causes one listener to be bound to each list item\r\nDom411('#Delegated')\r\n    .delegate('.item', 'grab.left', start)\r\n    .delegate('.item', 'drag.left', move)\r\n    .delegate('.item', 'drop.left', stop)\r\n\r\nfunction start (e) {\r\n    timer = e.timeStamp\r\n    total = 0\r\n    top = parseInt(this.style.top, 10) || 0\r\n    left = parseInt(this.style.left, 10) || 0\r\n}\r\nfunction stop (e) {\r\n    var duration = e.timeStamp - timer\r\n    document.getElementById('count').innerHTML = Math.round(total / (duration / 1000))\r\n}\r\nfunction move (e) {\r\n    total++\r\n    this.style.top = (top += e.movementY) + 'px'\r\n    this.style.left = (left += e.movementX) + 'px'\r\n}\r\n\r\nArray.prototype.slice.call(document.querySelectorAll('#Native > .item')).forEach(function (node) {\r\n    node.addEventListener('mousedown', function (e) {\r\n        if (e.which !== 1) return\r\n        var self = this\r\n        start.call(this, e)\r\n        var lastEvent = e\r\n        document.body.addEventListener('mousemove', dragHandler, true)\r\n        document.body.addEventListener('mouseup', mouseup, true)\r\n        function mouseup (e) {\r\n            if (e.which !== 1) return\r\n            stop(e)\r\n            document.body.removeEventListener('mousemove', dragHandler, true)\r\n            document.body.removeEventListener('mouseup', mouseup, true)\r\n        }\r\n        function dragHandler (e) {\r\n            if (e.which !== 1) return\r\n            total++\r\n            self.style.top = (top += e.clientY - lastEvent.clientY) + 'px'\r\n            self.style.left = (left += e.clientX - lastEvent.clientX) + 'px'\r\n            lastEvent = e\r\n        }\r\n    }, true)\r\n})\r\n\r\n// Using only native events, though, enhanced by jquery\r\n// $('#list3 > .item').on('mousedown', function (e) {\r\n//     start.call(this, e)\r\n//     lastEvent = e\r\n//     var dragHandler = jqMove.bind(this)\r\n//     $(document.body)\r\n//         .on('mousemove', dragHandler)\r\n//         .one('mouseup', function (e) {\r\n//             stop(e)\r\n//             $(document.body).off('mousemove', dragHandler)\r\n//         })\r\n// })\r\n// var lastEvent\r\n// function jqMove (e) {\r\n//     total++\r\n//     this.style.top = (top += e.clientY - lastEvent.clientY) + 'px'\r\n//     this.style.left = (left += e.clientX - lastEvent.clientX) + 'px'\r\n//     lastEvent = e\r\n// }\r\n\r\nfunction simulateDrag (element, direction, iterations) {\r\n    var box = element.getBoundingClientRect()\r\n    var mouse = {\r\n        x: (box.left + box.right) / 2,\r\n        y: (box.top + box.bottom) / 2\r\n    }\r\n    happen.mousedown(element, {\r\n        clientX: mouse.x,\r\n        clientY: mouse.y,\r\n        button:0\r\n    })\r\n    while (iterations-- >= 0) {\r\n        happen.mousemove(element, {\r\n            clientX: mouse.x += direction.x,\r\n            clientY: mouse.y += direction.y,\r\n            button:0\r\n        })\r\n    }\r\n    happen.mouseup(element, {\r\n        clientX: mouse.x,\r\n        clientY: mouse.y,\r\n        button:0\r\n    })\r\n}\r\nfunction timeDrag (el, cycles , distance) {\r\n    var start = now()\r\n    while (cycles-- >= 0 ) {\r\n        simulateDrag(el, {x:1,y:1}, distance)\r\n        simulateDrag(el, {x:-1,y:-1}, distance)\r\n    }\r\n    return (now() - start).toFixed(2)\r\n}\r\n\r\nfunction insertResult (el, cycles, distance) {\r\n    var node = document.createElement('div')\r\n    node.innerHTML= cycles*2+\r\n    ' grab, move: '+distance+'px, drop cycles'+\r\n    ' completed in <span class=\"time\">'+timeDrag(el.children[0], cycles, distance)+'ms</span>'\r\n    node.className = 'result'\r\n    el.appendChild(node)\r\n}\r\n\r\nfunction test (el) {\r\n    return all([\r\n        function () {\r\n            var p = new Promise\r\n            setTimeout(function () {\r\n                insertResult(el, 500, 10)\r\n                p.resolve()\r\n            }, 50)\r\n            return p\r\n        }(),\r\n        function () {\r\n            var p = new Promise\r\n            setTimeout(function () {\r\n                insertResult(el, 50, 500)\r\n                p.resolve()\r\n            }, 1000)\r\n            return p\r\n        }()\r\n    ])\r\n}\r\n\r\nfunction runAll () {\r\n    Dom411('ul').each(function () {\r\n        Array.prototype.slice.call(this.querySelectorAll('.result')).forEach(function (node) {\r\n            node.parentElement.removeChild(node)\r\n        })\r\n    })\r\n    Mouse.off()\r\n    test(document.getElementById('Native'))\r\n        .then(Mouse.on.bind(Mouse))\r\n        .then(function () {\r\n            return test(document.getElementById('Direct'))\r\n        })\r\n        .then(function () {\r\n            return test(document.getElementById('Delegated'))\r\n        })\r\n}\r\n// Allow test reruns. These could show up browser optimisations\r\nDom411('#counter button')[0].addEventListener('click', runAll, true)\r\n\r\nrunAll()",
        "/home/jkroso/Dev/Libraries/Mouse/demo/happen.js": "// Make inheritance bearable: clone one level of properties\r\nfunction extend(child, parent) {\r\n    for (var property in parent) {\r\n        if (typeof child[property] == 'undefined') {\r\n            child[property] = parent[property];\r\n        }\r\n    }\r\n    return child;\r\n}\r\n\r\nexports.once = once\r\nfunction once (x, o) {\r\n    var evt;\r\n\r\n    if (o.type.slice(0,3) === 'key') {\r\n        evt = document.createEvent('KeyboardEvent');\r\n        var initEvent;\r\n        \r\n        if (evt.initKeyEvent) {\r\n            // https://developer.mozilla.org/en/DOM/event.initKeyEvent\r\n            initEvent = evt.initKeyEvent\r\n        } else {\r\n            // https://developer.mozilla.org/en/DOM/KeyboardEvent\r\n            initEvent = evt.initKeyboardEvent\r\n        }\r\n\r\n        evt.initEvent(\r\n            o.type, //  in DOMString typeArg,\r\n            true,   //  in boolean canBubbleArg,\r\n            true,   //  in boolean cancelableArg,\r\n            null,   //  in nsIDOMAbstractView viewArg,  Specifies UIEvent.view. This value may be null.\r\n            false,  //  in boolean ctrlKeyArg,\r\n            false,  //  in boolean altKeyArg,\r\n            false,  //  in boolean shiftKeyArg,\r\n            false,  //  in boolean metaKeyArg,\r\n            72,     //  in unsigned long keyCodeArg,\r\n            0       //  in unsigned long charCodeArg);\r\n        )\r\n    } else {\r\n\r\n        evt = document.createEvent('MouseEvents');\r\n        // https://developer.mozilla.org/en/DOM/event.initMouseEvent\r\n        evt.initMouseEvent(o.type,\r\n            true, // canBubble\r\n            true, // cancelable\r\n            window, // 'AbstractView'\r\n            o.clicks || 0, // click count\r\n            o.screenX || 0, // screenX\r\n            o.screenY || 0, // screenY\r\n            o.clientX || 0, // clientX\r\n            o.clientY || 0, // clientY\r\n            o.ctrl || 0, // ctrl\r\n            o.alt || false, // alt\r\n            o.shift || false, // shift\r\n            o.meta || false, // meta\r\n            o.button || false, // mouse button\r\n            null // relatedTarget\r\n        );\r\n    }\r\n\r\n    x.dispatchEvent(evt);\r\n};\r\n\r\nvar shortcuts = ['click', 'mousedown', 'mouseup', 'mousemove', 'keydown', 'keyup', 'keypress'],\r\n    s, i = 0;\r\n\r\nwhile (s = shortcuts[i++]) {\r\n    exports[s] = (function(s) {\r\n        return function(x, o) {\r\n            once(x, extend(o || {}, { type: s }));\r\n        };\r\n    })(s);\r\n}\r\n\r\nexports.dblclick = function(x, o) {\r\n    once(x, extend(o || {}, {\r\n        type: 'dblclick',\r\n        clicks: 2\r\n    }));\r\n};\r\n",
        "/home/jkroso/Dev/Libraries/Mouse/src/index.js": "var Button = require('./Button.js'),\r\n    bitMask = [1, 2, 4]\r\n\r\nmodule.exports = Mouse\r\n\r\nfunction Mouse (view) {\r\n    var self = this\r\n    this.view = view\r\n    this.x = 0\r\n    this.y = 0\r\n    this[1] = new Button('left')\r\n    this[2] = new Button('middle')\r\n    this[3] = new Button('left+middle')\r\n    this[4] = new Button('right')\r\n    this[5] = new Button('left+right')\r\n    this[6] = new Button('middle+right')\r\n    this[7] = new Button('left+middle+right')\r\n    // this.down = null // `this.down` will become a singly linked list of active buttons\r\n    this.buttons = 0\r\n    this.lastActivity = Date.now()\r\n    this.last = {x:0,y:0}\r\n    \r\n    // `this` will refer to a DOM element when triggered\r\n    this.stateHandlers = {\r\n        mousedown : function (e) {\r\n            // Add the button to the front of a linked list of active buttons\r\n            // if ( self.down )\r\n                // e.previousDown = self.down\r\n            // self.down = e\r\n            self.buttons += bitMask[e.button]\r\n            // Delegate the event to the correct button\r\n            self[self.buttons].onDown(e)\r\n            // self.sequence(e)\r\n            self.update(e)\r\n        },\r\n        mouseup : function (e) {\r\n            // Remove the corresponding down event from the daisy chain of active buttons\r\n            // var downEvent = self.down\r\n            // if ( downEvent.which === e.which ) {\r\n            //     self.down = downEvent.previousDown\r\n            // } else {\r\n            //     do {\r\n            //         if ( downEvent.previousDown.which === e.which ) {\r\n            //             downEvent.previousDown = downEvent.previousDown.previousDown\r\n            //             break\r\n            //         }\r\n            //     } while ( downEvent = downEvent.previousDown )\r\n            // }\r\n            // Delegate the event to the correct button\r\n            // self.sequence()\r\n            self[self.buttons].onUp(e)\r\n            self.buttons -= bitMask[e.button]\r\n            self.update(e)\r\n        },\r\n        mousemove : function (e) {\r\n            e.movementX = e.x - self.last.x\r\n            e.movementY = e.y - self.last.y\r\n            // Some browsers fire move events when they shouldn't\r\n            if ( !(e.movementX || e.movementY) ) {\r\n                e.stopPropagation()\r\n                e.stopImmediatePropagation()\r\n                return\r\n            }\r\n            // If the mouse is being dragged\r\n            if ( self.buttons ) {\r\n                self[self.buttons].onMove(e)\r\n            }\r\n            var moveEvents = ['move']\r\n            \r\n            if ( e.movementY > 0 )\r\n                moveEvents.push(['up'])\r\n            else if ( e.movementY < 0 )\r\n                moveEvents.push(['down'])\r\n\r\n            if ( e.movementX > 0 )\r\n                moveEvents.push(['right'])\r\n            else if ( e.movementX < 0 )\r\n                moveEvents.push(['left'])\r\n                \r\n            e.types = [moveEvents]\r\n            \r\n            self.x = e.x\r\n            self.y = e.y\r\n            self.update(e)\r\n        },\r\n        // drag : function (e) {\r\n        //     var dragAspects = self._beforeDrag,\r\n        //         i = dragAspects.length\r\n        //     if ( i ) {\r\n        //         do {\r\n        //             dragAspects[--i](e, self)\r\n        //         } while ( i )\r\n        //     }\r\n        // },\r\n        mousewheel: function (e) {\r\n            if ( e.wheelDelta > 0 )\r\n                e.types = [['wheel', ['up']]]\r\n            else\r\n                e.types = [['wheel', ['down']]]\r\n            \r\n            if ( e.wheelDeltaX > 0 )\r\n                e.types[0].push(['left'])\r\n            else if ( e.wheelDeltaX < 0 )\r\n                e.types[0].push(['right'])\r\n\r\n            // self.sequence(e)\r\n            self.update(e)\r\n        },\r\n        mouseover: function (e) {\r\n            if ( e.relatedTarget === null ) {\r\n                self.active = true\r\n                self.update(e)\r\n            }\r\n            e.types = ['over']\r\n            e.name = 'over'\r\n        },\r\n        mouseout: function (e) {\r\n            if (e.relatedTarget === null) {\r\n                self.active = false\r\n                self.update(e)\r\n            }\r\n            e.types = ['out']\r\n            e.name = 'out'\r\n        }\r\n        /*FIXEME: the contextmenu prevents any events from being triggerd if they occur over it. This often leads to miscalculated `mouse.buttons`.\r\n        contextmenu : function (e) {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            e.stopImmediatePropagation()\r\n        }*/\r\n    }\r\n\r\n    this.on()\r\n}\r\n\r\nvar proto = Mouse.prototype\r\n\r\n// Start tracking\r\nproto.on = function () {\r\n    Object.keys(this.stateHandlers).forEach(function ( type ) {\r\n        this.view.addEventListener(type, this.stateHandlers[type], true)\r\n    }, this)\r\n}\r\n\r\n// Stop tracking\r\nproto.off = function () {\r\n    Object.keys(this.stateHandlers).forEach(function ( type ) {\r\n        this.view.removeEventListener(type, this.stateHandlers[type], true)\r\n    }, this)\r\n}\r\n\r\nproto.update = function (e) {\r\n    this.last = e\r\n    this.lastActivity = e.timeStamp\r\n}\r\n\r\n// function sequence (e) {\r\n//     var result = [e.name]\r\n//     while ( e.previous ) {\r\n//         e = e.previous\r\n//         result.unshift(e.name)\r\n//     }\r\n//     return result.join(',')\r\n// }\r\n\r\nObject.keys(proto).forEach(function(key) {\r\n    Object.defineProperty(Mouse, key, { \r\n        value : proto[key] \r\n    })\r\n    Object.defineProperty(proto, key, { enumerable: false })\r\n})\r\n// Why not re-use the constructor as an instance\r\nMouse.call(Mouse, window)\r\n\r\nif ( typeof Window !== 'undefined' )\r\n    Window.prototype.Mouse = Mouse",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/laissez-faire/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/promises/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/src/Button.js": "module.exports = Button\r\n\r\nfunction Button (which) {\r\n    this.lastDown = {\r\n        timeStamp : 0,\r\n        x : 0,\r\n        y : 0\r\n    }\r\n    this.lastUp = this.lastDown\r\n    this.last = this.lastDown\r\n    this.down = false\r\n    this.dragging = false\r\n    this.name = which\r\n}\r\n\r\nvar proto = Button.prototype\r\n\r\nproto.onDown = function (e) {\r\n    if ( e.target === this.lastDown.target && e.timeStamp - this.lastDown.timeStamp < 350 )\r\n        e.types = ['double', this.name]\r\n    else \r\n        e.types = ['down', this.name]\r\n\r\n    this.lastActivity = e.timeStamp\r\n    this.down = true\r\n    this.last = this.lastDown = e\r\n    e.name = 'down.'+this.name\r\n}\r\nproto.onUp = function (e) {\r\n    if ( this.dragging ) {\r\n        this.dragging = false\r\n        var event = new CustomEvent('library', {\r\n            bubbles : true,\r\n            cancelable : true\r\n        })\r\n        event.x = e.x\r\n        event.y = e.y\r\n        event.types = ['drop', this.name]\r\n        event.name = 'drop.'+this.name\r\n        this.lastDown.target.dispatchEvent(event)\r\n    } else if ( e.target === this.lastDown.target && e.timeStamp - this.lastDown.timeStamp < 350 ) {\r\n        e.types = [['click', [this.name]]]\r\n    } else\r\n        e.types = [['up', [this.name]]]\r\n    \r\n    this.down = false\r\n    this.last = this.lastUp = e\r\n    e.name = 'up.'+this.name\r\n    return event || e\r\n}\r\nproto.onMove = function (e) {\r\n    var event\r\n    if ( !this.dragging ) {\r\n        // We need to publish a grab event separately before any other events as this will allow drag listeners to be added \r\n        this.dragging = true\r\n        event = new Event('library', {\r\n            bubbles : true,\r\n            cancelable : true\r\n        })\r\n        event.x = this.lastDown.x\r\n        event.y = this.lastDown.y\r\n        event.types = ['grab', this.name]\r\n        event.name = 'grab.'+this.name\r\n        this.lastDown.target.dispatchEvent(event)\r\n    }\r\n    // When dragging the target should always be the one clicked on. To enable this to be true we need to create a custom event. I tried canceling the move event an re-dispatching it towards the correct target but this throws `DOM_exception error 1`\r\n    event = new Event('library', {\r\n        bubbles : true,\r\n        cancelable : true\r\n    })\r\n    event.types = ['drag', this.name]\r\n    // Movement is change in mouse position\r\n    event.movementX = e.movementX\r\n    event.movementY = e.movementY\r\n    // Delta is the movement occuring on the button\r\n    event.deltaX = (event.x = e.x) - this.last.x\r\n    event.deltaY = (event.y = e.y) - this.last.y\r\n    event.totalX = e.x - this.lastDown.x\r\n    event.totalY = e.y - this.lastDown.y\r\n    event.name = 'drag.'+this.name\r\n    this.lastDown.target.dispatchEvent(event)\r\n}",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/src/index.js": "var Bus = require('Bus'),\r\n    Context = require('Context'),\r\n    invokeList = Bus.invokeList, \r\n    collect = Bus.collect, \r\n    branchingCollect = Bus.branchingCollect\r\n\r\nmodule.exports = Context\r\n\r\n// Shim browser support\r\nElement.prototype.matchesSelector = Element.prototype.matchesSelector\r\n    || Element.prototype.webkitMatchesSelector\r\n    || Element.prototype.mozMatchesSelector\r\n    || Element.prototype.msMatchesSelector\r\n    || Element.prototype.oMatchesSelector\r\n    || function (selector) {\r\n        var nodes = this.parentNode.querySelectorAll(selector),\r\n            len = nodes.length\r\n        while (len--) {\r\n            if (nodes[len] === this) return true\r\n        }\r\n        return false\r\n    }\r\n\r\n// All of the mouse events which get exposed in the API require a certain DOM event in order to work properly. This table provides the conversion\r\nvar translate = {\r\n    down  : 'mousedown',\r\n    up    : 'mouseup',\r\n    move  : 'mousemove',\r\n    over  : 'mouseover',\r\n    out   : 'mouseout',\r\n    click : 'mouseup',\r\n    wheel : 'mousewheel',\r\n    double: 'mouseup',\r\n    type  : 'input'\r\n}\r\nvar subjects = new WeakMap\r\n\r\n// The handler used for all DOM events. It plucks event type info of the event object and hands it to the Observer instance that was mapped to `this` DOM node\r\nfunction dispatch (e) {\r\n    var types = e.types || [e.type]\r\n    return invokeList(\r\n        // Test the format of the event directive...\r\n        typeof types[0] === 'string' ?\r\n            // ...['mouse', 'up']\r\n            collect(subjects.get(this), types) :\r\n            // ...[['mouse', ['up']]]\r\n            branchingCollect(subjects.get(this), types),\r\n        e)\r\n}\r\n\r\n// Create an instance of Observer and add it to the node-subject map\r\nfunction createSubject (node) {\r\n    var s = Object.defineProperties(new Bus, {\r\n        _capturing : {\r\n            value : Object.create(null),\r\n            writable : true\r\n        },\r\n        _bubbling : {\r\n            value : Object.create(null),\r\n            writable : true\r\n        }\r\n    })\r\n    subjects.set(node, s)\r\n    return s\r\n}\r\n\r\n// Find the first top level topic in a topic sequence string. e.g. travel.left would return travel. If in the translation table this top level topic will be translated in the native version\r\nfunction topType (topic) {\r\n    var firstDot = topic.indexOf('.'),\r\n        eventType = firstDot >= 0 ? topic.slice(0, firstDot) : topic        \r\n    return eventType in translate ? translate[eventType] : 'library'\r\n}\r\n\r\nfunction incCount (eGenre, counter) {\r\n    if ( typeof counter[eGenre] === 'undefined' ) {\r\n        counter[eGenre] = 0\r\n    }\r\n    return ++counter[eGenre]\r\n}\r\n\r\nfunction decCount (eGenre, counter) {\r\n    var count = --counter[eGenre]\r\n    if (  count <= 0 ) {\r\n        delete counter[eGenre]\r\n    }\r\n    return count\r\n}\r\n\r\n// A helper for creating Event instances\r\nfunction CustomEvent (options) {\r\n    var event = new Event('library', {\r\n        bubbles : true,\r\n        cancelable : true\r\n    })\r\n    Object.keys(options).forEach(function (key) {\r\n        event[key] = options[key]\r\n    })\r\n    return event\r\n}\r\n\r\nContext.Event = CustomEvent\r\nvar proto = Context.prototype\r\n\r\nproto.trigger = function (topic, data) {\r\n    if ( topic instanceof Event ) {\r\n        this.each(function () {\r\n            this.dispatchEvent(CustomEvent(topic))\r\n        })\r\n    } else {\r\n        if ( typeof topic !== 'string' ) {\r\n            data = topic\r\n            topic = ''\r\n        }\r\n        this.each(function () {\r\n            this.dispatchEvent(CustomEvent({\r\n                types : topic.split(/\\./),\r\n                name : topic,\r\n                data : data\r\n            }))\r\n        })\r\n    }\r\n    return this\r\n}\r\n\r\nproto.on = function (topics, fn, bubbles) {\r\n    // Default the bubbles option to false\r\n    if ( typeof bubbles !== 'boolean' ) bubbles = false\r\n    if ( typeof topics === 'string' ) {\r\n        this.each(function () {\r\n            var subject = subjects.get(this) || createSubject(this)\r\n            topics.split(/\\s+/).forEach(function (topic) {\r\n                var eGenre = topType(topic)\r\n                if ( incCount(eGenre, bubbles ? subject._capturing : subject._bubbling) === 1 ) {\r\n                    this.addEventListener(eGenre, dispatch, bubbles)\r\n                }\r\n            }, this)\r\n            subject.on(topics, this, fn)\r\n        })\r\n    // Assume there is no topic; create a top level event\r\n    } else {\r\n        // Check if a bubbles option was provided\r\n        if ( typeof fn === 'boolean' ) bubbles = fn\r\n        this.each(function () {\r\n            var subject = subjects.get(this) || createSubject(this)\r\n            if ( incCount('library', bubbles ? subject._capturing : subject._bubbling) === 1 ) {\r\n                this.addEventListener('library', dispatch, bubbles)\r\n            }\r\n            subject.on(this, topics) // topics is the fn\r\n        })\r\n    }\r\n    return this\r\n}\r\n\r\nproto.next = function (topics, fn, bubbles) {\r\n    // Keep a ref to the original set so all nodes will have this handler removed not just the one that actually gets triggered\r\n    var self = this\r\n    this.on(topics, function callback (e) {\r\n        self.off(topics, callback, bubbles)\r\n        fn.call(this)\r\n    }, bubbles)\r\n}\r\n\r\nproto.delegate = function (selector, topics, fn, bubbles) {\r\n    this.each(function (node) {\r\n        Context(this).on(topics, function delegater (e) {\r\n            var target = e.target\r\n            while (target !== this) {\r\n                if ( target.matchesSelector(selector) ) return fn.call(target, e)\r\n                target = target.parentElement\r\n            }\r\n        }, bubbles)\r\n    })\r\n    return this\r\n}\r\n\r\nproto.off = function (topics, fn, bubbles) {\r\n    var args = arguments\r\n    if ( typeof topics === 'string' ) {\r\n        if ( typeof bubbles !== 'boolean' ) bubbles = true\r\n        this.each(function () {\r\n            var subject = subjects.get(this)\r\n            if ( ! subject ) return\r\n            topics.split(/\\s+/).forEach(function (topic) {\r\n                var eGenre = topType(topic)\r\n                if ( decCount(eGenre, bubbles ? subject._capturing : subject._bubbling) === 0 ) {\r\n                    this.removeEventListener(eGenre, dispatch, bubbles)\r\n                }\r\n            }, this)\r\n            subject.off(topics, fn)\r\n        })\r\n    } else if (arguments.length) {\r\n        fn = topics\r\n        bubbles = typeof fn === 'boolean' ? fn : true\r\n        this.each(function () {\r\n            var subject = subjects.get(this)\r\n            if ( ! subject ) return\r\n            if ( decCount('library', bubbles ? subject._capturing : subject._bubbling) === 0 ) {\r\n                this.removeEventListener('library', dispatch, bubbles)\r\n            }\r\n            subject.off(fn)\r\n        })\r\n    } else {\r\n        this.each(function () {\r\n            var subject = subjects.get(this)\r\n            if ( ! subject ) return\r\n            Object.keys(subject._bubbling).forEach(function (key) {\r\n                this.removeEventListener(key, dispatch, false)\r\n            }, this)\r\n            Object.keys(subject._capturing).forEach(function (key) {\r\n                this.removeEventListener(key, dispatch, true)\r\n            }, this)\r\n            subjects.delete(this)\r\n        })\r\n    }\r\n    return this\r\n}\r\n\r\nproto.transferListeners = function (target) {\r\n    var node = this[0]\r\n    if ( subjects.has(node) ) {\r\n        var subject = subjects.get(node)\r\n        subjects.delete(node)\r\n        \r\n        Object.keys(subject._DOMListeners).forEach(function (key) {\r\n            node.removeEventListener(key, dispatch, true)\r\n            target.addEventListener(key, dispatch, true)\r\n        })\r\n        subjects.set(target, subject)\r\n    }\r\n    return this\r\n}",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/laissez-faire/src/index.js": "exports = module.exports = Promise\r\n\r\n/**\r\n * Promise class\r\n */\r\nfunction Promise () {this.length = 0}\r\n\r\n/**\r\n * Dafualt uncought error handler. It will wait 1 second for you to handle the error before logging it to the console. Feel free to replace this function with one you find more useful. Its purely a debugging feature. Technically promises throw unhandled exceptions. They just sit around waiting for you to handle them\r\n * \r\n * @param  {Promise} promise The promise that was rejected without an error handler or child promise\r\n * @param  {Error} e       The Error instance emitted by the promise\r\n */\r\nexports.prepareException = function (promise, e) {\r\n    promise._throw = setTimeout(function () {\r\n        if (e instanceof Error) {\r\n            e.message += ' (Rethrown from rejected promise)'\r\n            throw e\r\n        } else {\r\n            console.warn('Not handled within 1 second: ', e)\r\n        }\r\n    }, 1000)\r\n}\r\n\r\n/**\r\n * Sometimes error handlers may be added after a promise has been rejected. If you would like to cancel any undhandled exception handling logging logic you can do so by replaceing this function\r\n * \r\n * @param  {Promise} promise The promise which previously failed without error handlers\r\n */\r\nexports.cancelException = function (promise) {\r\n    clearTimeout(promise._throw);\r\n    delete promise._throw\r\n}\r\n\r\n/**\r\n * Helper to quickly create a rejected promise\r\n * @param  {Error} e\r\n * @return {Promise}\r\n */\r\nexports.rejected = newRejected\r\nfunction newRejected (e) {\r\n    var p = new Promise\r\n    p.reason = e\r\n    p.then = rejectedThen\r\n    p.end = rejectedEnd\r\n    return p\r\n}\r\n\r\n/**\r\n * Helper to quickly create a completed promise\r\n * @param  {!Error} value can be == null just not an Error\r\n * @return {Promise}\r\n */\r\nexports.fulfilled = newFulfilled\r\nfunction newFulfilled (value) {\r\n    var p = new Promise\r\n    p.value = value\r\n    p.then = resolvedThen\r\n    p.end = resolvedEnd\r\n    return p\r\n}\r\n\r\n/**\r\n * Process the value safely and ensure that what is returned is represented via a new promise\r\n * \r\n * @param {Function|null} fn        A handler from the current promise\r\n * @param {Any}           value     The result from computing the previous promise     \r\n */\r\nfunction run (fn, value) {\r\n    var result\r\n    try {\r\n        result = fn(value)\r\n    } catch (e) {\r\n        return newRejected(e)\r\n    }\r\n    if (isPromise(result)) {\r\n        // No need to create a new promise if we already have one\r\n        return result === value ? result.then() : result\r\n    } else {\r\n        return newFulfilled(result)\r\n    }\r\n}\r\n\r\n/**\r\n * Handle the processing of a promise and resolve or reject it based on the results\r\n * \r\n * @param  {Promise}  promise The promise we are computing the value for\r\n * @param  {Function} fn      either the success or error handler\r\n * @param  {Any}      value   The input\r\n */\r\nfunction propagate (promise, fn, value) {\r\n    try {\r\n        value = fn(value)\r\n    } catch (e) {\r\n        return promise.reject(e)\r\n    }\r\n    if (isPromise(value)) {\r\n        // prefer .end() \r\n        value[typeof value.end === 'function' ? 'end': 'then'](\r\n            function (val) {promise.resolve(val)}, \r\n            function (err) {promise.reject(err) })\r\n    }\r\n    else {\r\n        promise.resolve(value)\r\n    }\r\n}\r\n\r\nexports.is = isPromise\r\nfunction isPromise (item) {\r\n    return item && typeof item.then === 'function'\r\n}\r\n\r\nvar proto = Promise.prototype = Object.create(\r\n    require('jkroso-emitter').prototype, \r\n    {constructor:{value:Promise}}\r\n)\r\n// Default states.\r\nproto.value = proto.reason = undefined\r\n\r\n/**\r\n * Create a follow up process\r\n * \r\n * @param  {Function} done\r\n * @param  {Function} fail\r\n * @return {Promise} This is a new promise which will be either fulfilled \r\n * or rejected based on the return value of the done/fail params\r\n */\r\nproto.then = function(done, fail) {\r\n    var thenPromise\r\n    this[this.length++] = (thenPromise = new Promise)\r\n    thenPromise._success = done\r\n    thenPromise._fail = fail\r\n    return thenPromise\r\n}\r\n// Alternative then methods\r\nfunction resolvedThen (fn) {\r\n    return fn \r\n        ? run(fn, this.value) \r\n        : newFulfilled(this.value)\r\n}\r\nfunction rejectedThen (_, fn) {\r\n    Promise.cancelException(this)\r\n    return fn \r\n        ? run(fn, this.reason)\r\n        : newRejected(this.reason)\r\n}\r\n\r\n/**\r\n * Like then but is designed for terminal operations. So any values generated will not be available for follow up and uncaught errors will be thrown. Use this method in place of then when you don't plan to do anything with the stuff generated by your callbacks\r\n * \r\n * @param  {Function}   done \r\n * @param  {Function}   fail \r\n * @return {Self}  p.end() === p; Allowing jquery style use of promises\r\n */\r\nproto.stub = proto.throw = function (done, fail) {return this.end(done, fail)}\r\nproto.end = function (done, fail) {\r\n    // Queue a sudo-promise capable of throwing errors\r\n    this[this.length++] = {\r\n        // Handlers are bound to the assignment properties since these aren't run inside a try catch. Having no handlers is fine, the values will just pass straight through to the resolvers.\r\n        resolve: done || noop,\r\n        // Interestingly if we didn't provide an error thrower as a backup we would still be guaranteed to throw at the right time. However it would be \"no such method\" instead of the users error.\r\n        reject: fail || function (e) {throw e}\r\n    }\r\n    return this\r\n}\r\n// Alternative `end` methods for when the state of the promise changes\r\nfunction resolvedEnd (fn) {\r\n    fn && fn(this.value)\r\n    return this\r\n}\r\nfunction rejectedEnd (_, fn) {\r\n    Promise.cancelException(this)\r\n    if (!fn) throw this.reason\r\n    fn(this.reason)\r\n    return this\r\n}\r\n\r\n/**\r\n * Create a terminal follow up branch with no success callback\r\n * @param  {Function} fn error handler\r\n * @return {Promise}\r\n */\r\nproto.fail = function (fn) {\r\n    return this.end(null, fn)\r\n}\r\n\r\n/**\r\n * If you pass callbacks it will act like .end otherwise it will attempt to return its resolution synchronously\r\n * @param  {Function} done optional\r\n * @param  {Function} fail optional\r\n * @return {Self|Any}\r\n */\r\nproto.valueOf = function (done, fail) {\r\n    if (done || fail) return this.end(done, fail)\r\n    switch (this.then) {\r\n        case resolvedThen: return this.value\r\n        case rejectedThen: return this.reason\r\n        default: return this\r\n    }\r\n}\r\n\r\n/**\r\n * Convenience function for creating a propagating error handler\r\n * @param  {Function} errback\r\n * @return {Promise}\r\n */\r\nproto.otherwise = function (errback) {\r\n    return this.then(null, errback)\r\n}\r\n\r\n/**\r\n * Convenience function to bind the same function to both done and fail\r\n * @param  {Function} callback\r\n * @return {Promise}\r\n */\r\nproto.always = function (callback) {\r\n    return this.then(callback, callback)\r\n}\r\n\r\n/**\r\n * A terminal version version of always\r\n * @param  {Function} callback\r\n * @return {Self}\r\n */\r\nproto.finish = function (callback) {\r\n    return this.end(callback, callback)\r\n}\r\n\r\n/**\r\n * Allows the use of node style callbacks\r\n * @param  {Function} callback [err, value]\r\n * @return {Promise}\r\n */\r\nproto.node = function (callback) {\r\n    return this.then(function (val) {return callback(null, val)}, callback)\r\n}\r\n\r\n/**\r\n * Provides simple access to the promises value via a node style callback\r\n * @param  {Function} callback [error, value]\r\n * @return {Self}\r\n */\r\nproto.nend = function (callback) {\r\n    return this.end(function (val) {callback(null, val)}, callback)\r\n}\r\n\r\n/**\r\n * Give the promise it's value and trigger all process branches\r\n * \r\n * @param  {!Error} value Can be anything other than an Error\r\n * @return {Self}\r\n */\r\nproto.resolve = function (value) {\r\n    // Change the state\r\n    this.value = value\r\n    \r\n    // Change the behavior. In a parallel universe this is just a matter of swapping the prototype.\r\n    this.resolve = this.reject = noop\r\n    this.then = resolvedThen\r\n    this.end = resolvedEnd\r\n\r\n    // Propagate the value to any queued promises.\r\n    var child, i = 0\r\n    // Use a forward loop to maintain insertion order\r\n    while (child = this[i++]) {\r\n        if (child._success) propagate(child, child._success, value)\r\n        else child.resolve(value)\r\n    }\r\n    return this\r\n}\r\n\r\n/**\r\n * Delegates to resolve or reject, depending on the value given\r\n * @param  {Any} unknown\r\n * @return {self}\r\n */\r\nproto.assign = function (unknown) {\r\n    return this[unknown instanceof Error ? 'reject' : 'resolve'](unknown)\r\n}\r\n\r\n/**\r\n * Break the promise and propagate the error to subsequent process branches\r\n * \r\n * @param  {Error} e The reason for rejection\r\n * @return {Self}\r\n */\r\nproto.reject = function (e) {\r\n    this.reason = e\r\n    \r\n    this.resolve = this.reject = noop\r\n    this.then = rejectedThen\r\n    this.end = rejectedEnd\r\n    \r\n    var i = 0, child\r\n    if (child = this[i]) {\r\n        do {\r\n            if (child._fail) propagate(child, child._fail, e)\r\n            else child.reject(e)\r\n        } while (child = this[++i])\r\n    }\r\n    else {\r\n        // If a promise is rejected without any child promises we might have a genuine error. The following method provides a place for users to access these errors.\r\n        Promise.prepareException(this, e)\r\n    }\r\n    return this\r\n}\r\n\r\n/**\r\n * Create a promise destined to resolve with a given value\r\n * @param  {Any} value\r\n * @return {Promise}\r\n */\r\nproto.yeild = function (value) {\r\n    return this.then(function () {return value})\r\n}\r\n\r\nproto.isRejected = function () {\r\n    return this.then === rejectedThen\r\n}\r\nproto.isFulfilled = function () {\r\n    return this.then === resolvedThen\r\n}\r\n\r\n/**\r\n * Generate a safe interface for a promise\r\n * \r\n * @return {Object} The promise with minimal interface\r\n */\r\nproto.proxy = function () {\r\n    var self = this\r\n    return Object.create(null, {then: {value:function(a,b){\r\n        // The returned promise does not need to be proxied since the goblin owns this one\r\n        return self.then(a,b)\r\n    }}})\r\n}\r\n\r\nfunction noop () {}\r\n",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/promises/src/index.js": "var Promise = require('laissez-faire'),\r\n    newResolved = Promise.fulfilled,\r\n    newRejected = Promise.rejected\r\n\r\nexports = module.exports = Collection\r\n\r\nfunction Collection () {\r\n    var self = Object.create(Collection.prototype),\r\n        len = arguments.length, \r\n        i = self.length = 0\r\n    while (i < len) {\r\n        if (arguments[i] != null) {\r\n            self[self.length++] = toTrustedPromise(arguments[i])\r\n        }\r\n        i++\r\n    }\r\n    return self\r\n}\r\n\r\nvar proto = Collection.prototype\r\n\r\nfunction toTrustedPromise (promise) {\r\n    if (isPromise(promise)) {\r\n        if (promise instanceof Promise) \r\n            return promise\r\n        else {\r\n            var p = new Promise\r\n            promise.then(function (v) {p.resolve(v)}, function (e) {p.reject(e)})\r\n            return p\r\n        }\r\n    }\r\n    return newResolved(promise)\r\n}\r\n\r\nfunction isOnlyArray (args) {\r\n    return args.length === 1 && isArrayIsh(args[0])\r\n}\r\n\r\nfunction isArrayIsh (item) {\r\n    return item.length \r\n        && typeof item !== 'function' \r\n        && typeof item !== 'string'\r\n}\r\n\r\nexports.isPromise = isPromise\r\nfunction isPromise (item) {\r\n    return item && typeof item.then === 'function'\r\n}\r\n\r\nvar concat = Array.prototype.concat\r\n\r\n/**\r\n * Decorate a node function to return a promise instead of taking a callback\r\n * \r\n * @param  {Function} fn Its last arg must to be function taking [err, value]\r\n * @return {Promise}\r\n */\r\nexports.nfApply = nfApply\r\nfunction nfApply (fn) {\r\n    return function () {\r\n        var deferred = new Promise\r\n        fn.apply(this, concat.call(arguments, function (err, value) {\r\n            if (err) deferred.reject(err)\r\n            else deferred.resolve(value)\r\n        }))\r\n        return deferred\r\n    }\r\n}\r\n\r\n/**\r\n * Decorate a callback based function to return a promise instead\r\n * \r\n * @param  {Function} fn Should take a function as its last argument with arg format [value]\r\n *         If value is an instance of Error the promise will be rejected, otherwise resolved\r\n * @return {Promise}\r\n */\r\nexports.cbApply = cbApply\r\nfunction cbApply (fn) {\r\n    return function () {\r\n        var deferred = new Promise\r\n        fn.apply(this, concat.call(arguments, function (value) {\r\n            deferred.assign(value)\r\n        }))\r\n        return deferred \r\n    }\r\n}\r\n\r\n/**\r\n * Call the handlers on some value even if that value is represented by a promise\r\n * @param  {Any}   item can be a thenable or anything else you like\r\n * @param  {Function} done \r\n * @param  {Function} fail\r\n * @return {Promise}  A new Promise\r\n */\r\nexports.when = when\r\nfunction when (item, done, fail) {\r\n    return toTrustedPromise(item).then(done, fail)\r\n}\r\n\r\n/**\r\n * Terminal version of when. Use once if you don't need a promise returned\r\n * @param  {Any}   item promise or otherwise. even null is fine\r\n * @param  {Function} done\r\n * @param  {Function} fail\r\n */\r\nexports.once = once\r\nfunction once (item, done, fail) {\r\n    // We don't worry whether its trusted or not since it only needs to be thenable\r\n    if (isPromise(item)) item.then(done, fail)\r\n    else done(item)\r\n}\r\n\r\nexports.from = fromArray\r\nfunction fromArray (array) {\r\n    return Collection.apply(null, array)\r\n}\r\n\r\nexports.all = function (array) {\r\n    return fromArray(array).all()\r\n}\r\n\r\nexports.any = exports.first = function (array) {\r\n    return fromArray(array).first()\r\n}\r\n\r\n/**\r\n * Apply handlers to every item in the collection. Works like Array#forEach\r\n * \r\n * @param  {Function} done [value, index, collection]\r\n * @param  {Function} fail [value, index, collection]\r\n * @return {Self}\r\n */\r\nproto.each = function (done, fail) {\r\n    var self = this, i = 0, len = this.length\r\n    // Using a function here to similate block scoping\r\n    while (i < len) block(i++)\r\n    function block (index) {\r\n        self[index].end(\r\n            done && function (value) {done(value, index, self)},\r\n            fail && function (error) {fail(error, index, self)}\r\n        )\r\n    }\r\n    return this\r\n}\r\n\r\n/**\r\n * Apply handlers to each item creating a new collection with the results (promised results to be precise)\r\n * \r\n * @param  {Function} done [value, index, collection]\r\n * @param  {Function} fail [value, index, collection]\r\n * @return {Promises} a new Promises collection\r\n */\r\nproto.map = function (done, fail) {\r\n    var self = this, results = new Collection, i = 0, len = results.length = this.length\r\n    while (i < len) block(i++)\r\n    function block (index) {\r\n        results[index] = self[index].then(\r\n            done && function (value) {return done(value, index, self)},\r\n            fail && function (reason) {return fail(reason, index, self)}\r\n        )\r\n    } \r\n    return results \r\n}\r\n\r\n/**\r\n * Combine values into a single value\r\n * @param  {Function} done    [current, next, index, array]\r\n * @param  {initial}   initial optional, defaults to an empty fulfilled promise\r\n * @return {result of last operation}\r\n */\r\nproto.reduce = function (done, initial) {\r\n    var self = this, i = 0, len = this.length\r\n    if (initial == null) {\r\n        if (!(initial = this[0])) return newRejected(new TypeError('No values to reduce'))\r\n        i = 1\r\n    } \r\n    else if (!isPromise(initial)) initial = newResolved(initial)\r\n    \r\n    while (i < len) block(i++)\r\n    function block (index) {\r\n        initial = initial.then(function (value) {\r\n            return self[index].then(function (next) {\r\n                return done(value, next, index, self)\r\n            })\r\n        })\r\n    }\r\n    return initial\r\n}\r\n\r\n/**\r\n * Provide resolved promises to their respective callbacks\r\n * \r\n * @param  {Function} done will receive all fulfilled promises\r\n * @param  {Function} fail will receive all rejected promises\r\n * @return {Promise}\r\n */\r\nproto.passed = function (done, fail) {\r\n    var p = new Promise,\r\n        passed = [],\r\n        count = this.length\r\n    this.each(\r\n        function (value, i) {passed[i] = value; check()},\r\n        function (error, i) {check()}\r\n    )\r\n    function check () {\r\n        if (--count <= 0) {\r\n            p.resolve(passed.filter(Boolean))\r\n        }\r\n    }\r\n    return p.then(done, fail)\r\n}\r\n\r\n/**\r\n * Create a promise for an array of resolved values. If all promises are fulfilled the overall promise will be fulfilled. Otherwise it will be rejected.\r\n * @param  {Function} done [array]\r\n * @param  {Function} fail [array]\r\n * @return {Promise}\r\n */\r\nproto.then = \r\nproto.all = function (done, fail) {\r\n    var p = new Promise, \r\n        results = [], \r\n        i = this.length, \r\n        count = i,\r\n        self = this\r\n\r\n    if (!(count)) p.resolve(results)\r\n    \r\n    while (i--) block(i)\r\n    function block (index) {\r\n        self[index].end(\r\n            function (value) {\r\n                results[index] = value\r\n                if (--count === 0) p.resolve(results)\r\n            },\r\n            function (error) {\r\n                if (!p.isFulfilled()) p.reject(error)\r\n                // In case this happened sync we can cancel loop\r\n                i = 0\r\n            }\r\n        )\r\n    }\r\n    return done || fail ? p.then(done, fail) : p\r\n}\r\n\r\n/**\r\n * Creates a promise for the first available value in the collection. If none are fulfilled the \"first\" promise will be rejected\r\n * @param  {Function} done\r\n * @param  {Function} fail\r\n * @return {Promise}\r\n */\r\nproto.first = function (done, fail) {\r\n    var p = new Promise,\r\n        count = this.length\r\n    if (!count) p.reject()\r\n    this.each(\r\n        function (value) {p.resolve(value)},\r\n        function () {if (--count <= 0) p.reject(new Error('None fulfilled'))}\r\n    )\r\n    return done || fail ? p.then(done, fail) : p\r\n}\r\n\r\nproto.otherwise = function (fn) {\r\n    return this.then(null, fn)\r\n}\r\n\r\nproto.always = function (fn) {\r\n    return this.then(fn, fn)\r\n}\r\n\r\n/**\r\n * Creates a new collection with items added\r\n * @return {Promises} new Promises collection\r\n */\r\nproto.append = function () {\r\n    var newCollection = Collection.apply(null, this), i = 0, len = arguments.length\r\n    while ( i < len ) {\r\n        if (arguments[i] != null) {\r\n            newCollection[newCollection.length++] = toTrustedPromise(arguments[i])\r\n        }\r\n        i++\r\n    }\r\n    return newCollection \r\n}\r\n\r\nproto.pop = function () {\r\n    delete this[--this.length]\r\n    return this \r\n}\r\n\r\n/**\r\n * Should unmatched items be rejected or marked as rejected?\r\n * \r\n * @param  {Function} callback [value, index, collection]\r\n * @return {Promises}\r\n */\r\nproto.filter = function (callback) {\r\n    var results = Collection.apply(null, this), \r\n        self = this, \r\n        i = 0,\r\n        len = this.length\r\n    while (i < len) block(i++)\r\n    function block (index) {\r\n        results[index] = self[index].then(function (value) {\r\n            if (typeof callback === 'function' && callback(value)) \r\n                return value\r\n            else \r\n                throw value\r\n        })\r\n    }\r\n    return results\r\n}\r\n\r\nproto.splice = function (start, howMany) {\r\n    var stop = this.length - howMany, i = start, len = this.length\r\n    if (howMany) {\r\n        do {\r\n            this[i] = this[i + howMany]\r\n        } while (++i < stop)\r\n        do {\r\n            delete this[i]\r\n            this.length--\r\n        } while (++i < len)\r\n    }\r\n    return this.insert.apply(this, [start].concat(Array.prototype.slice.call(arguments, 2)))\r\n}\r\n\r\nproto.insert = function (where) {\r\n    var items = Array.prototype.slice.call(arguments, 1), \r\n        howMany = items.length, \r\n        i = this.length\r\n    if (where > i) throw new Error('Invalid insertion point')\r\n    else if (where < 0) where = Math.max(0, i - where + 1)\r\n    this.length += howMany\r\n    // Shift items after where over enough slots to fit in items\r\n    while (i-- > where) {\r\n        this[i + howMany] = this[i]\r\n    }\r\n    // Place items into the gap\r\n    while (howMany--) {\r\n        this[where + howMany] = toTrustedPromise(items[howMany])\r\n    }\r\n    return this\r\n}",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/laissez-faire/node_modules/jkroso-emitter/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/node_modules/Context/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/node_modules/Bus/package.json": 'module.exports = require("./src/index.js")',
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/node_modules/Context/src/index.js": "module.exports = Context\r\n    \r\nfunction Context (subjects, area) {\r\n    if ( !(this instanceof Context) ) return new Context(subjects, area)\r\n\r\n    if ( typeof subjects === 'string' ) {\r\n        subjects = (area || document).querySelectorAll(subjects)\r\n        area = 0\r\n        while ( area < subjects.length ) {\r\n            this[area] = subjects[area++]\r\n        }\r\n        this.length = area\r\n    } else {\r\n        this.length = 0\r\n        this.add(subjects)\r\n    }\r\n}\r\n\r\nvar proto = Context.prototype\r\n\r\nproto.each = function (fn) {\r\n    for ( var i = 0, len = this.length; i < len; i++ ) {\r\n        fn.call(this[i], i, this)\r\n    }\r\n    return this\r\n}\r\n\r\nproto.add = function() {\r\n    if ( arguments[0] ) {\r\n        if ( !(arguments[0] instanceof Element) ) arguments = arguments[0]\r\n        var node\r\n        for ( var i = 0, len = arguments.length; i < len; i++ ) {\r\n            // Is it a DOM node?\r\n            (node = arguments[i]) instanceof Element\r\n                // Is it already in the set?\r\n                && Array.prototype.indexOf.call(this, node) === -1\r\n                // Go ahead and add it\r\n                && Array.prototype.push.call(this, node)\r\n        }\r\n    }\r\n    return this\r\n}\r\n\r\nproto.subtract = function() {\r\n    if ( arguments[0] ) {\r\n        if ( !(arguments[0] instanceof Element) ) arguments = arguments[0]\r\n        var len = arguments.length, i\r\n        while ( len-- ) {\r\n            i = this.length\r\n            while ( i-- ) {\r\n                if ( this[i] === arguments[len] ) {\r\n                    Array.prototype.splice.call(this, i--, 1)\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this\r\n}",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/laissez-faire/node_modules/jkroso-emitter/src/index.js": "'use strict';\r\n\r\nmodule.exports = Emitter\r\n\r\nfunction Emitter () {this._callbacks = {}}\r\n\r\nEmitter.new = function () {\r\n    return new(this)\r\n}\r\n\r\nEmitter.mixin = function (obj) {\r\n    Object.keys(proto).forEach(function (key) {\r\n        Object.defineProperty(obj, key, {\r\n            value: proto[key], \r\n            writable:true,\r\n            configurable:true \r\n        })\r\n    })\r\n    return obj\r\n}\r\n\r\nvar proto = Emitter.prototype\r\n\r\nproto.emit = proto.publish = function (topic, data) {\r\n    var calls\r\n    if ((calls = this._callbacks) && (calls = calls[topic])) {\r\n        topic = calls.length\r\n        while (topic--) {\r\n            calls[topic].call(calls[--topic], data)\r\n        }\r\n    }\r\n    return this\r\n}\r\n\r\nproto.on = function (topics, callback, context) {\r\n    topics = topics.split(/\\s+/)\r\n    var calls = this._callbacks || (this._callbacks = {}),\r\n        i = topics.length\r\n\r\n    while (i--)\r\n        // Push to the front of the array; Using concat to avoid mutating the old array\r\n        calls[topics[i]] = [context || this, callback].concat(calls[topics[i]] || [])\r\n\r\n    return this\r\n}\r\n\r\nproto.once = function (topics, callback, context) {\r\n    var self = this\r\n    return this.on(\r\n        topics, \r\n        function on (data) {\r\n            self.off(topics, on)\r\n            return callback.call(context, data)\r\n        }, \r\n        context\r\n    )\r\n}\r\n\r\nproto.off = function (topics, callback) {\r\n    var calls\r\n    if ( calls = this._callbacks ) {\r\n        if ( topics ) {\r\n            if ( callback ) {\r\n                topics.split(/\\s+/).forEach(function (topic) {\r\n                    var events = calls[topic]\r\n                    if ( events ) {\r\n                        events = events.slice()\r\n                        var i = events.length\r\n                        while (i--) {\r\n                            if (events[i--] === callback) {\r\n                                events.splice(i, 2)\r\n                                calls[topic] = events\r\n                                break\r\n                            }\r\n                        }\r\n                    }                \r\n                })\r\n            } \r\n            else {\r\n                topics.split(/\\s+/).forEach(function (topic) {\r\n                    delete calls[topic]\r\n                })\r\n            }\r\n        } \r\n        else {\r\n            this._callbacks = {}\r\n        }\r\n    }\r\n    return this\r\n}",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/node_modules/Bus/src/index.js": "var Subscription = require('./Subscription')\r\n\r\nexports = module.exports = Bus\r\n\r\nfunction Bus (listeners) {\r\n    // Using discriptor to prevent non-subTopic properties from being enumerable\r\n    Object.defineProperty(this, '_listeners', {\r\n        value : listeners && Object.prototype.toString.call(listeners) === '[object Array]'\r\n            ? listeners \r\n            : [],\r\n        writable : true\r\n    })\r\n}\r\n\r\nvar proto = Bus.prototype\r\n\r\nexports.mixin = function (target) {\r\n    Bus.call(target)\r\n    Object.keys(proto).forEach(function (key) {\r\n        if ( !target.hasOwnProperty(key) ) {\r\n            Object.defineProperty(target, key, { \r\n                value: proto[key], \r\n                writable:true,\r\n                configurable:true \r\n            })\r\n        }\r\n    })\r\n    return target\r\n}\r\n\r\n/**\r\n * Iterate over a list of listeners invoking each one\r\n * @param  {Array}   topics should be an array of listener arrays from the topics objects you wish to invoke\r\n * @param  {Any}     data   whatever you want passed to each of the subscribers\r\n * @return {Boolean}        true if no listeners prevented propagation\r\n */\r\nexports.invokeList = invokeList\r\nfunction invokeList (topics, data) {\r\n    var len = topics.length, i, listeners\r\n    while ( len-- ) {\r\n        listeners = topics[len]\r\n        i = listeners.length\r\n        if ( i > 0 ) {\r\n            do {\r\n                // Returning false from a handler will prevent any further subscriptions from being notified\r\n                if ( listeners[--i].trigger(data) === false ) {\r\n                    return false\r\n                }\r\n            } while ( i )\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction insertListener (node, subscriptionData) {\r\n    var listeners = node._listeners.slice(),\r\n        priority = subscriptionData.priority,\r\n        added = false\r\n    \r\n    for ( var i = 0, len = listeners.length; i < len; i++ ) {\r\n        if ( listeners[i].priority >= priority ) {\r\n            listeners.splice(i, 0, subscriptionData)\r\n            added = true\r\n            break\r\n        }\r\n    }\r\n    if ( !added )\r\n        listeners.push(subscriptionData)\r\n    \r\n    node._listeners = listeners\r\n}\r\n\r\nfunction removeListener (node, callback) {\r\n    var check\r\n    switch ( typeof callback ) {\r\n        case 'function':\r\n            check = function (listenerData) {\r\n                return listenerData.callback !== callback\r\n            }\r\n            break\r\n        case 'string':\r\n            check = function (listenerData) {\r\n                return listenerData.callback.name !== callback\r\n            }\r\n            break\r\n        case 'object':\r\n            check = function (listenerData) {\r\n                return listenerData !== callback\r\n            }\r\n            break\r\n        default:\r\n            // if the user didn't pass a callback, all listeners will be removed\r\n            check = function () {\r\n                return false\r\n            }\r\n    }\r\n    node._listeners = node._listeners.filter(check)\r\n}\r\n\r\n// Recursive collect with the ability to fork and combine\r\nexports.branchingCollect = branchingCollect\r\nfunction branchingCollect (node, directive) {\r\n    var i = 0,\r\n        len = directive.length,\r\n        direction,\r\n        key,\r\n        result = [node._listeners]\r\n    while ( i < len ) {\r\n        direction = directive[i++]\r\n        key = direction[0]\r\n        if ( key in node ) {\r\n            result = result.concat(branchingCollect(node[key], direction.slice(1)))\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n// Takes an list of directions to follow and collects all listeners along the way\r\nexports.collect = collect\r\nfunction collect (node, directions) {\r\n    var result = [node._listeners],\r\n        len = directions.length,\r\n        i = 0\r\n    while ( i < len ) {\r\n        node = node[directions[i++]]\r\n        if ( node )\r\n            result.push(node._listeners)\r\n        else\r\n            break\r\n    }\r\n    return result\r\n}\r\n\r\n// Retieves a a sub-topic from the descending tree\r\nproto.get = function (directions, useforce) {\r\n    if ( ! directions )\r\n        return this\r\n    directions = directions.split('.')\r\n    var topic = this,\r\n        edge,\r\n        len = directions.length,\r\n        i = 0\r\n    \r\n    if ( len ) {\r\n        do {\r\n            edge = directions[i++]\r\n            if ( topic[edge] instanceof Bus )\r\n                topic = topic[edge]\r\n            else if ( topic[edge] )\r\n                throw 'namespace clash: '+edge\r\n            else if ( useforce )\r\n                topic = topic[edge] = new Bus\r\n            else\r\n                break\r\n        } while ( i < len )\r\n    }\r\n    return topic\r\n}\r\n\r\n/**\r\n * If any callback returns false we immediately exit otherwise we simply return true to indicate that all callbacks were fired without interference\r\n * @param  {String} topic   the event type\r\n * @param  {Any}    data    any data you want passed to the callbacks\r\n * @return {Boolean}\r\n */\r\nproto.publish = function (topic, data) {\r\n    if ( typeof topic === 'string' ) {\r\n        topic = collect(this, topic.split('.'))\r\n    } else {\r\n        data = topic\r\n        topic = [this._listeners]\r\n    }\r\n    return invokeList(topic, data)\r\n}\r\n\r\n//  _Method_ __on__\r\n//  \r\n//  +   _optional_ __string__ `topics` a ' ' separate list of topics In the format `lvl1.lvl2.lvl3.etc`\r\n//  +   _optional_ __object__ `context`\r\n//  +   __function__ `callback` the function to handle events. Should take one argument, `data`\r\n//  +   _optional_ __number__ `priority` 1 will trigger before 2 etc  \r\n//  \r\n// returns `listenerObject`\r\nproto.on = function (topics, context, callback, priority) {\r\n    switch ( arguments.length ) {  \r\n        case 3:\r\n            if (typeof callback === 'number') {\r\n                priority = callback\r\n                callback = context\r\n                context = window\r\n            } else\r\n                priority = 0\r\n            break\r\n        case 2:\r\n            callback = context\r\n            priority = 0\r\n            if ( typeof topics === 'string' ) {\r\n                context = window\r\n            } else {\r\n                context = topics\r\n                topics = ''\r\n            }\r\n            break\r\n        case 1:\r\n            callback = topics\r\n            topics = ''\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 0:\r\n            throw 'Insufficient arguments'\r\n    }\r\n\r\n    var listenerData = new Subscription(context, callback, priority)\r\n\r\n    // Multiple subscriptions can be set at the same time, in fact it is recommended as they end up sharing memory this way. No need to throw error for incorrect topic since accessing `split` on a non-string will throw an error anyway\r\n    topics.split(/\\s+/).forEach(function (directions) {\r\n        insertListener(this.get(directions, true), listenerData)\r\n    },this)\r\n    return listenerData\r\n}\r\n\r\n// Same api as on except as soon as one topic is triggered the listener will be removed from __all__ topics it was subscribed to in the `once` call\r\nproto.once = function (topics, context, callback, priority) {\r\n    switch ( arguments.length ) {  \r\n        case 3:\r\n            if (typeof callback === 'number') {\r\n                priority = callback\r\n                callback = context\r\n                context = window\r\n            } else\r\n                priority = 0\r\n            break\r\n        case 2:\r\n            callback = context\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 1:\r\n            callback = topics\r\n            topics = ''\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 0:\r\n            throw 'Insufficient arguments'\r\n    }\r\n    var listenerData = new Subscription(context, callback, priority)\r\n    listenerData._topics = []\r\n    listenerData.trigger = function (data) {\r\n        this._topics.forEach(function (topic) {\r\n            removeListener(topic, this)\r\n        }, this)\r\n        return this.callback.call(this.context, data)\r\n    }\r\n    topics.split(/\\s+/).forEach(function (directions) {\r\n        var topicObject = this.get(directions, true)\r\n        listenerData._topics.push(topicObject)\r\n        insertListener(topicObject, listenerData)\r\n    }, this)\r\n\r\n    return listenerData\r\n}\r\n\r\n//  _Method_ __off__\r\n//  \r\n//  +   __String__ `topic` the event type  \r\n//  +   _optional_ __function|subscriptionRef|string__ `callback`  \r\n//    + If you do not pass a callback then all subscriptions will be removed from that topic\r\n//    + If you pass a string then all subscriptions with a callback name matching that string will be remove\r\n//    + If you pass a function then all subscriptions with that function will be removed\r\nproto.off = function (topics, callback) {\r\n    if (typeof topics !== 'string') {\r\n        if ( !callback )\r\n            return removeListener(this, topics) // `topics` in this case being the `callback`\r\n        else \r\n            throw 'Bad topic argument'\r\n    }\r\n    if ( arguments.length ) {\r\n        topics.split(/\\s+/).forEach(function (topic) {\r\n            topic = this.get(topic, false)\r\n            if ( topic )\r\n                removeListener(topic, callback)\r\n        }, this)\r\n    // Clear everything\r\n    } else {\r\n        Object.keys(this).forEach(function (key) {\r\n            // Check that it isn't some special property\r\n            if ( this[key] instanceof Bus ) {\r\n                delete this[key]\r\n            }\r\n        }, this)\r\n        this._listeners = []\r\n    }\r\n}\r\n",
        "/home/jkroso/Dev/Libraries/Mouse/node_modules/Dom411/node_modules/Bus/src/Subscription.js": "module.exports = Subscription\r\n\r\nfunction Subscription (context, callback, priority) {\r\n    if ( typeof callback !== 'function' || typeof priority !== 'number' )\r\n        throw 'Incorrect argument format'\r\n    this.context = context\r\n    this.callback = callback\r\n    this.priority = priority\r\n}\r\n\r\nvar proto = Subscription.prototype\r\n\r\nproto.trigger = function (data) {\r\n    return this.callback.call(this.context, data)\r\n}\r\n"
    };
    require("/home/jkroso/Dev/Libraries/Mouse/demo/demo.js");
}();