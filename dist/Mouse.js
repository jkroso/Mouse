!function(){function e(t){var r=n[t];return"string"==typeof r&&Function("module","exports","require","eval("+JSON.stringify(r+"\n//@ sourceURL=/"+t)+")").call((n[t]=r={exports:{}}).exports,r,r.exports,e),r.exports}var n=["var Button = require(1),\r\n    bitMask = [1, 2, 4]\r\n\r\nmodule.exports = Mouse\r\n\r\nfunction Mouse (view) {\r\n    var self = this\r\n    this.view = view\r\n    this.x = 0\r\n    this.y = 0\r\n    this[1] = new Button('left')\r\n    this[2] = new Button('middle')\r\n    this[3] = new Button('left+middle')\r\n    this[4] = new Button('right')\r\n    this[5] = new Button('left+right')\r\n    this[6] = new Button('middle+right')\r\n    this[7] = new Button('left+middle+right')\r\n    // this.down = null // `this.down` will become a singly linked list of active buttons\r\n    this.buttons = 0\r\n    this.lastActivity = Date.now()\r\n    this.last = {x:0,y:0}\r\n    \r\n    // `this` will refer to a DOM element when triggered\r\n    this.stateHandlers = {\r\n        mousedown : function (e) {\r\n            // Add the button to the front of a linked list of active buttons\r\n            // if ( self.down )\r\n                // e.previousDown = self.down\r\n            // self.down = e\r\n            self.buttons += bitMask[e.button]\r\n            // Delegate the event to the correct button\r\n            self[self.buttons].onDown(e)\r\n            // self.sequence(e)\r\n            self.update(e)\r\n        },\r\n        mouseup : function (e) {\r\n            // Remove the corresponding down event from the daisy chain of active buttons\r\n            // var downEvent = self.down\r\n            // if ( downEvent.which === e.which ) {\r\n            //     self.down = downEvent.previousDown\r\n            // } else {\r\n            //     do {\r\n            //         if ( downEvent.previousDown.which === e.which ) {\r\n            //             downEvent.previousDown = downEvent.previousDown.previousDown\r\n            //             break\r\n            //         }\r\n            //     } while ( downEvent = downEvent.previousDown )\r\n            // }\r\n            // Delegate the event to the correct button\r\n            // self.sequence()\r\n            self[self.buttons].onUp(e)\r\n            self.buttons -= bitMask[e.button]\r\n            self.update(e)\r\n        },\r\n        mousemove : function (e) {\r\n            e.movementX = e.x - self.last.x\r\n            e.movementY = e.y - self.last.y\r\n            // Some browsers fire move events when they shouldn't\r\n            if ( !(e.movementX || e.movementY) ) {\r\n                e.stopPropagation()\r\n                e.stopImmediatePropagation()\r\n                return\r\n            }\r\n            // If the mouse is being dragged\r\n            if ( self.buttons ) {\r\n                self[self.buttons].onMove(e)\r\n            }\r\n            var moveEvents = ['move']\r\n            \r\n            if ( e.movementY > 0 )\r\n                moveEvents.push(['up'])\r\n            else if ( e.movementY < 0 )\r\n                moveEvents.push(['down'])\r\n\r\n            if ( e.movementX > 0 )\r\n                moveEvents.push(['right'])\r\n            else if ( e.movementX < 0 )\r\n                moveEvents.push(['left'])\r\n                \r\n            e.types = [moveEvents]\r\n            \r\n            self.x = e.x\r\n            self.y = e.y\r\n            self.update(e)\r\n        },\r\n        // drag : function (e) {\r\n        //     var dragAspects = self._beforeDrag,\r\n        //         i = dragAspects.length\r\n        //     if ( i ) {\r\n        //         do {\r\n        //             dragAspects[--i](e, self)\r\n        //         } while ( i )\r\n        //     }\r\n        // },\r\n        mousewheel: function (e) {\r\n            if ( e.wheelDelta > 0 )\r\n                e.types = [['wheel', ['up']]]\r\n            else\r\n                e.types = [['wheel', ['down']]]\r\n            \r\n            if ( e.wheelDeltaX > 0 )\r\n                e.types[0].push(['left'])\r\n            else if ( e.wheelDeltaX < 0 )\r\n                e.types[0].push(['right'])\r\n\r\n            // self.sequence(e)\r\n            self.update(e)\r\n        },\r\n        mouseover: function (e) {\r\n            if ( e.relatedTarget === null ) {\r\n                self.active = true\r\n                self.update(e)\r\n            }\r\n            e.types = ['over']\r\n            e.name = 'over'\r\n        },\r\n        mouseout: function (e) {\r\n            if (e.relatedTarget === null) {\r\n                self.active = false\r\n                self.update(e)\r\n            }\r\n            e.types = ['out']\r\n            e.name = 'out'\r\n        }\r\n        /*FIXEME: the contextmenu prevents any events from being triggerd if they occur over it. This often leads to miscalculated `mouse.buttons`.\r\n        contextmenu : function (e) {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            e.stopImmediatePropagation()\r\n        }*/\r\n    }\r\n\r\n    this.on()\r\n}\r\n\r\nvar proto = Mouse.prototype\r\n\r\n// Start tracking\r\nproto.on = function () {\r\n    Object.keys(this.stateHandlers).forEach(function ( type ) {\r\n        this.view.addEventListener(type, this.stateHandlers[type], true)\r\n    }, this)\r\n}\r\n\r\n// Stop tracking\r\nproto.off = function () {\r\n    Object.keys(this.stateHandlers).forEach(function ( type ) {\r\n        this.view.removeEventListener(type, this.stateHandlers[type], true)\r\n    }, this)\r\n}\r\n\r\nproto.update = function (e) {\r\n    this.last = e\r\n    this.lastActivity = e.timeStamp\r\n}\r\n\r\n// function sequence (e) {\r\n//     var result = [e.name]\r\n//     while ( e.previous ) {\r\n//         e = e.previous\r\n//         result.unshift(e.name)\r\n//     }\r\n//     return result.join(',')\r\n// }\r\n\r\nObject.keys(proto).forEach(function(key) {\r\n    Object.defineProperty(Mouse, key, { \r\n        value : proto[key] \r\n    })\r\n    Object.defineProperty(proto, key, { enumerable: false })\r\n})\r\n// Why not re-use the constructor as an instance\r\nMouse.call(Mouse, window)\r\n\r\nif ( typeof Window !== 'undefined' )\r\n    Window.prototype.Mouse = Mouse\n//@ sourceURL=/home/jkroso/Dev/Libraries/Mouse/src/index.js","module.exports = Button\r\n\r\nfunction Button (which) {\r\n    this.lastDown = {\r\n        timeStamp : 0,\r\n        x : 0,\r\n        y : 0\r\n    }\r\n    this.lastUp = this.lastDown\r\n    this.last = this.lastDown\r\n    this.down = false\r\n    this.dragging = false\r\n    this.name = which\r\n}\r\n\r\nvar proto = Button.prototype\r\n\r\nproto.onDown = function (e) {\r\n    if ( e.target === this.lastDown.target && e.timeStamp - this.lastDown.timeStamp < 350 )\r\n        e.types = ['double', this.name]\r\n    else \r\n        e.types = ['down', this.name]\r\n\r\n    this.lastActivity = e.timeStamp\r\n    this.down = true\r\n    this.last = this.lastDown = e\r\n    e.name = 'down.'+this.name\r\n}\r\nproto.onUp = function (e) {\r\n    if ( this.dragging ) {\r\n        this.dragging = false\r\n        var event = new CustomEvent('library', {\r\n            bubbles : true,\r\n            cancelable : true\r\n        })\r\n        event.x = e.x\r\n        event.y = e.y\r\n        event.types = ['drop', this.name]\r\n        event.name = 'drop.'+this.name\r\n        this.lastDown.target.dispatchEvent(event)\r\n    } else if ( e.target === this.lastDown.target && e.timeStamp - this.lastDown.timeStamp < 350 ) {\r\n        e.types = [['click', [this.name]]]\r\n    } else\r\n        e.types = [['up', [this.name]]]\r\n    \r\n    this.down = false\r\n    this.last = this.lastUp = e\r\n    e.name = 'up.'+this.name\r\n    return event || e\r\n}\r\nproto.onMove = function (e) {\r\n    var event\r\n    if ( !this.dragging ) {\r\n        // We need to publish a grab event separately before any other events as this will allow drag listeners to be added \r\n        this.dragging = true\r\n        event = new Event('library', {\r\n            bubbles : true,\r\n            cancelable : true\r\n        })\r\n        event.x = this.lastDown.x\r\n        event.y = this.lastDown.y\r\n        event.types = ['grab', this.name]\r\n        event.name = 'grab.'+this.name\r\n        this.lastDown.target.dispatchEvent(event)\r\n    }\r\n    // When dragging the target should always be the one clicked on. To enable this to be true we need to create a custom event. I tried canceling the move event an re-dispatching it towards the correct target but this throws `DOM_exception error 1`\r\n    event = new Event('library', {\r\n        bubbles : true,\r\n        cancelable : true\r\n    })\r\n    event.types = ['drag', this.name]\r\n    // Movement is change in mouse position\r\n    event.movementX = e.movementX\r\n    event.movementY = e.movementY\r\n    // Delta is the movement occuring on the button\r\n    event.deltaX = (event.x = e.x) - this.last.x\r\n    event.deltaY = (event.y = e.y) - this.last.y\r\n    event.totalX = e.x - this.lastDown.x\r\n    event.totalY = e.y - this.lastDown.y\r\n    event.name = 'drag.'+this.name\r\n    this.lastDown.target.dispatchEvent(event)\r\n}\n//@ sourceURL=/home/jkroso/Dev/Libraries/Mouse/src/Button.js"];Mouse=e(0)}();